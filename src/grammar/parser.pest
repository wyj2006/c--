WHITESPACE = _{ " " | "\t" | NEWLINE }
identifier = ${ !(keyword ~ !identifier_continue) ~ identifier_start ~ identifier_continue* }
COMMENT    = _{ "//" ~ (!(NEWLINE | EOI) ~ ANY)* ~ NEWLINE? | "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

prefix      = _{ positve | negative | bit_not | not | dereference | addressof | prefix_increment | prefix_decrement | cast | sizeof }
positve     =  { "+" }
negative    =  { "-" }
bit_not     =  { "~" }
not         =  { "!" }
dereference =  { "*" }
addressof   =  { "&" }
// 如果后面跟的是'{', 那么这个就应该属于复合字面量
cast             = { "(" ~ type_name ~ ")" ~ !"{" }
sizeof           = { "sizeof" }
prefix_increment = { "++" }
prefix_decrement = { "--" }

infix   = _{ add | sub | mul | div | mod | lshift | rshift | lt | le | gt | ge | eq | neq | and | or | bit_and | bit_xor | bit_or }
add     =  { "+" }
sub     =  { "-" }
mul     =  { "*" }
div     =  { "/" }
mod     =  { "%" }
lshift  =  { "<<" }
rshift  =  { ">>" }
lt      =  { "<" }
le      =  { "<=" }
gt      =  { ">" }
ge      =  { ">=" }
eq      =  { "==" }
neq     =  { "!=" }
bit_and =  { "&" }
bit_xor =  { "^" }
bit_or  =  { "|" }
and     =  { "&&" }
or      =  { "||" }
comma   =  { "," }

postfix            = _{ subscript | function_call | member_access | postfix_increment | postfix_decrement }
subscript          =  { "[" ~ expression ~ "]" }
function_call      =  { "(" ~ function_arguments? ~ ")" }
function_arguments = _{ assignment_expression ~ ("," ~ assignment_expression)* ~ ","? }
member_access      =  { "." ~ identifier | "->" ~ identifier }
postfix_increment  =  { "++" }
postfix_decrement  =  { "--" }

primary      = {
    compound_literal
  | generic_selection
  | constant
  | string_group
  | identifier
  | "(" ~ expression ~ ")"
}
string_group = { string_literal+ }

generic_selection   = { "_Generic" ~ "(" ~ assignment_expression ~ ("," ~ generic_association)+ ~ ")" }
generic_association = { (type_name | "default") ~ ":" ~ assignment_expression }

compound_literal = { "(" ~ storage_class_specifier* ~ type_name ~ ")" ~ braced_initializer }

sizeof_type      = { "sizeof" ~ "(" ~ type_name ~ ")" }
alignof          = { "alignof" ~ "(" ~ type_name ~ ")" }
unary_expression = {
    sizeof_type
  | alignof
  | prefix* ~ primary ~ postfix*
}

logical_OR_expression = { unary_expression ~ (infix ~ unary_expression)* }

conditional_expression = { logical_OR_expression ~ "?" ~ expression ~ ":" ~ conditional_expression | logical_OR_expression }

assignment_expression = { unary_expression ~ assignment_operator ~ assignment_expression | conditional_expression }
assignment_operator   = { "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | "&=" | "|=" | "^=" }

expression = { assignment_expression ~ (comma ~ assignment_expression)* }

constant_expression = { conditional_expression }

declaration                            =  {
    attribute_specifier_sequence ~ declaration_specifiers_without_typedef ~ init_declarator_list ~ ";"
  | attribute_specifier_sequence ~ declaration_specifiers_with_typedef ~ init_declarator_list ~ ";"
  | declaration_specifiers_without_typedef ~ init_declarator_list? ~ ";"
  | declaration_specifiers_with_typedef ~ init_declarator_list? ~ ";"
  | static_assert_declaration
  | attribute_declaration
}
declaration_specifiers_without_typedef =  {
    declaration_specifier+ ~ attribute_specifier_sequence?
}
declaration_specifiers_with_typedef    =  {
    declaration_specifier* ~ typedef_name ~ declaration_specifier* ~ attribute_specifier_sequence?
}
declaration_specifier                  = _{
    storage_class_specifier
  | type_specifier_qualifier
  | function_specifier
}
init_declarator_list                   = _{ init_declarator ~ ("," ~ init_declarator)* }
init_declarator                        = _{ declarator ~ "=" ~ initializer | declarator }
attribute_declaration                  =  { attribute_specifier_sequence ~ ";" }

storage_class_specifier = {
    "auto"
  | "constexpr"
  | "extern"
  | "register"
  | "static"
  | "thread_local"
  | "typedef"
}

type_specifier = {
    "void"
  | "char"
  | "short"
  | "int"
  | "long"
  | "float"
  | "double"
  | "signed"
  | "unsigned"
  | "_BitInt" ~ "(" ~ constant_expression ~ ")"
  | "bool"
  | "_Complex"
  | "_Decimal32"
  | "_Decimal64"
  | "_Decimal128"
  | atomic_type_specifier
  | struct_or_union_specifier
  | enum_specifier
  | typeof_specifier
}

struct_or_union_specifier                =  {
    ("struct" | "union") ~ attribute_specifier_sequence? ~ identifier? ~ "{" ~ member_declaration+ ~ "}"
  | ("struct" | "union") ~ attribute_specifier_sequence? ~ identifier
}
member_declaration                       =  {
    attribute_specifier_sequence? ~ specifier_qualifier_list_without_typedef ~ member_declarator_list? ~ ";"
  | attribute_specifier_sequence? ~ specifier_qualifier_list_with_typedef ~ member_declarator_list? ~ ";"
  | static_assert_declaration
}
specifier_qualifier_list_without_typedef =  {
    type_specifier_qualifier+ ~ attribute_specifier_sequence?
  | type_specifier_qualifier* ~ typedef_name ~ type_specifier_qualifier* ~ attribute_specifier_sequence?
}
specifier_qualifier_list_with_typedef    =  {
    type_specifier_qualifier* ~ typedef_name ~ type_specifier_qualifier* ~ attribute_specifier_sequence?
}
type_specifier_qualifier                 = _{
    type_specifier
  | type_qualifier
  | alignment_specifier
}
member_declarator_list                   = _{
    member_declarator ~ ("," ~ member_declarator)*
}
member_declarator                        =  {
    declarator? ~ ":" ~ constant_expression
  | declarator
}

enum_specifier      =  {
    "enum" ~ attribute_specifier_sequence? ~ identifier? ~ enum_type_specifier? ~ "{" ~ enumerator_list ~ ","? ~ "}"
  | "enum" ~ identifier ~ enum_type_specifier?
}
enumerator_list     = _{ enumerator ~ ("," ~ enumerator)* }
enumerator          =  {
    identifier ~ attribute_specifier_sequence? ~ ("=" ~ constant_expression)?
}
enum_type_specifier = _{
    ":" ~ specifier_qualifier_list_without_typedef
  | ":" ~ specifier_qualifier_list_with_typedef
}

atomic_type_specifier = { "_Atomic" ~ "(" ~ type_name ~ ")" }

typeof_specifier = {
    ("typeof_unqual" | "typeof") ~ "(" ~ (expression | type_name) ~ ")"
}

type_qualifier = {
    "const"
  | "restrict"
  | "volatile"
  | "_Atomic"
}

function_specifier = {
    "inline"
  | "_Noreturn"
}

alignment_specifier = { "alignas" ~ "(" ~ (constant_expression | type_name) ~ ")" }

declarator            =  { pointer* ~ direct_declarator }
direct_declarator     =  {
    (name_declarator | "(" ~ declarator ~ ")") ~ (array_declarator | function_declarator)*
}
name_declarator       =  { identifier ~ attribute_specifier_sequence? }
array_declarator      =  {
    "[" ~ static ~ type_qualifier_list? ~ assignment_expression ~ "]" ~ attribute_specifier_sequence?
  | "[" ~ type_qualifier_list ~ static ~ assignment_expression ~ "]" ~ attribute_specifier_sequence?
  | "[" ~ type_qualifier_list? ~ star ~ "]" ~ attribute_specifier_sequence?
  | "[" ~ type_qualifier_list? ~ assignment_expression? ~ "]" ~ attribute_specifier_sequence?
}
static                =  { "static" }
star                  =  { "*" }
function_declarator   =  { "(" ~ parameter_type_list? ~ ")" ~ attribute_specifier_sequence? }
pointer               =  { "*" ~ attribute_specifier_sequence? ~ type_qualifier_list? }
type_qualifier_list   =  { type_qualifier+ }
parameter_type_list   = _{
    parameter_list ~ "," ~ "..."
  | parameter_list
  | "..."
}
parameter_list        = _{ parameter_declaration ~ ("," ~ parameter_declaration)* }
parameter_declaration =  {
    attribute_specifier_sequence? ~ declaration_specifiers_without_typedef ~ (declarator | abstract_declarator?)
  | attribute_specifier_sequence? ~ declaration_specifiers_with_typedef ~ (declarator | abstract_declarator?)
}

type_name                    = {
    specifier_qualifier_list_without_typedef ~ abstract_declarator?
  | specifier_qualifier_list_with_typedef ~ abstract_declarator?
}
abstract_declarator          = { pointer* ~ direct_abstract_declarator | pointer+ }
direct_abstract_declarator   = {
    // 保证direct_abstract_declarator不为空
    "(" ~ abstract_declarator ~ ")" ~ ((array_abstract_declarator | function_abstract_declarator) ~ attribute_specifier_sequence?)*
  | ((array_abstract_declarator | function_abstract_declarator) ~ attribute_specifier_sequence?)+
}
array_abstract_declarator    = {
    "[" ~ static ~ type_qualifier_list? ~ assignment_expression ~ "]"
  | "[" ~ type_qualifier_list ~ static ~ assignment_expression ~ "]"
  | "[" ~ type_qualifier_list? ~ assignment_expression? ~ "]"
  | "[" ~ star ~ "]"
}
function_abstract_declarator = { "(" ~ parameter_type_list? ~ ")" }

typedef_name = { identifier }

braced_initializer =  { "{" ~ (initializer_list ~ ","?)? ~ "}" }
initializer        =  { braced_initializer | assignment_expression }
initializer_list   = _{ designation? ~ initializer ~ ("," ~ designation? ~ initializer)* }
designation        =  { designator+ ~ "=" }
designator         = _{
    "[" ~ constant_expression ~ "]"
  | "." ~ identifier
}

static_assert_declaration = { "static_assert" ~ "(" ~ constant_expression ~ ("," ~ string_literal)? ~ ")" ~ ";" }

attribute_specifier_sequence =  { attribute_specifier+ }
attribute_specifier          = _{ "[" ~ "[" ~ attribute_list ~ "]" ~ "]" }
attribute_list               = _{ attribute? ~ ("," ~ attribute?)* }
attribute                    =  { attribute_token ~ attribute_argument_clause? }
attribute_token              =  { attribute_prefixed_token | standard_attribute }
standard_attribute           = _{ identifier }
attribute_prefixed_token     = _{ attribute_prefix ~ "::" ~ identifier }
attribute_prefix             =  { identifier }
attribute_argument_clause    =  { "(" ~ balanced_token_sequence? ~ ")" }
balanced_token_sequence      =  { balanced_token+ }
balanced_token               =  {
    "(" ~ balanced_token_sequence? ~ ")"
  | "[" ~ balanced_token_sequence? ~ "]"
  | "{" ~ balanced_token_sequence? ~ "}"
  | !(")" | "]" | "}") ~ token
}

statement           =  {
    labeled_statement
  | unlabeled_statement
}
unlabeled_statement =  {
    expression_statement
  | attribute_specifier_sequence? ~ primary_block
  | attribute_specifier_sequence? ~ jump_statement
}
primary_block       = _{
    compound_statement
  | selection_statement
  | iteration_statement
}
secondary_block     = _{ statement }

label             = {
    attribute_specifier_sequence? ~ identifier ~ ":"
  | attribute_specifier_sequence? ~ "case" ~ constant_expression ~ ":"
  | attribute_specifier_sequence? ~ "default" ~ ":"
}
labeled_statement = { label ~ statement }

compound_statement =  { "{" ~ block_item* ~ "}" }
block_item         = _{
    // expression和declaration的二义性将在语义分析中解决
    declaration
  | unlabeled_statement
  | label
}

expression_statement = _{
    attribute_specifier_sequence ~ expression ~ ";"
  | expression? ~ ";"
}

selection_statement = {
    "if" ~ "(" ~ expression ~ ")" ~ secondary_block ~ ("else" ~ secondary_block)?
  | "switch" ~ "(" ~ expression ~ ")" ~ secondary_block
}

iteration_statement = {
    "while" ~ "(" ~ expression ~ ")" ~ secondary_block
  | "do" ~ secondary_block ~ "while" ~ "(" ~ expression ~ ")" ~ ";"
  | "for" ~ "(" ~ declaration ~ expression? ~ ";" ~ expression? ~ ")" ~ secondary_block
  | "for" ~ "(" ~ expression? ~ ";" ~ expression? ~ ";" ~ expression? ~ ")" ~ secondary_block
}

jump_statement = {
    "goto" ~ identifier ~ ";"
  | "continue" ~ ";"
  | "break" ~ ";"
  | "return" ~ expression? ~ ";"
}

translation_unit     =  { SOI ~ external_declaration* ~ EOI }
external_declaration = _{
    function_definition
  | declaration
}

function_definition =  {
    attribute_specifier_sequence? ~ declaration_specifiers_without_typedef ~ declarator ~ function_body
  | attribute_specifier_sequence? ~ declaration_specifiers_with_typedef ~ declarator ~ function_body
}
function_body       = _{ compound_statement }
